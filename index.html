<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous"> -->

    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"> -->
    <title>Hello world!</title>
    <style>

      #gameScreen {
	  border: 2px solid #222;
	  margin: 10px;
      }

      img {
	  display: none;
      }
      
    </style>


  </head>
  <body>
    <!-- <div class="container"> -->
    <!--   <h1 class="text-center mt-5">Exercises JS</h1> -->
    <!-- </div> -->

    <div id="root" class="container">

      <!-- <form> -->
      <!-- 	<input type="url" name="website" placeholder="http://johndoe.com" required pattern="(http|https)://.+" /> -->
      <!-- 	</form> -->
      
    </div>
    <img id="img-ball" src="https://www.flaticon.com/svg/static/icons/svg/1165/1165187.svg">
    <img id="img-brick" src="https://www.flaticon.com/svg/static/icons/svg/705/705804.svg">
    <canvas id="gameScreen" width="800" height="600"></canvas>
    <script>
      
      const canvas = document.querySelector("#gameScreen");
      const ctx = canvas.getContext("2d");

      const gameWidth = 800;
      const gameHeight = 600;

      const level1 = [
	  [0,1,0,1,0,1,0,1,0,1],
	  [1,1,1,1,1,1,1,1,1,1],
	  [1,1,1,1,1,1,1,1,1,1],
	  [1,1,1,1,1,1,1,1,1,1],
      ]

      function buildLevel(game, level) {
	  let bricks = [];

	  level.forEach((row, rowIndex) => {
	      row.forEach((brick, brickIndex) => {
		  
	      })
	  })
      }
      

      class Paddle {
	  constructor(game) {
	      this.gameWidth = game.gameWidth;
	      this.width = 150;
	      this.height = 20;
	      this.maxSpeed = 7;
	      this.speed = 0;
	      this.position = {
		  x: game.gameWidth / 2 - this.width / 2,
		  y: game.gameHeight - this.height - 10,
	      }
	  }

	  draw(ctx) {
	      ctx.fillStyle = "#333"
	      ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
	  }
	  
	  update(deltaTime) {
	      this.position.x += this.speed;
	      if (this.position.x < 0) this.position.x = 0;
	      if (this.position.x + this.width > this.gameWidth) this.position.x = this.gameWidth - this.width;
	  }

	  moveLeft() {
	      this.speed = -this.maxSpeed;
	  }

	  moveRight() {
	      this.speed = this.maxSpeed;
	  }
	  
	  stop() {
	      this.speed = 0;
	  }
      }

      class InputHandler {
	  constructor(paddle) {
	      document.addEventListener("keydown", (event) => {
		  switch (event.keyCode) {
		  case 37:
		      paddle.moveLeft();
		      break;
		  case 39:
		      paddle.moveRight();
		      break;
		  }
	      });

	      document.addEventListener("keyup", (event) => {
		  switch (event.keyCode) {
		  case 37:
		      if (paddle.speed < 0) paddle.stop();
		      break;
		  case 39:
		      if (paddle.speed > 0) paddle.stop();
		      break;
		  }
	      });
	  }

	  
      }

      class Ball {
	  constructor(game) {
	      this.gameWidth = game.gameWidth;
	      this.gameHeight = game.gameHeight;
	      this.image = document.querySelector("#img-ball");

	      this.game = game;
	      this.position = {
		  x: 10,
		  y: 10,
	      };
	      this.speed = {
		  x: 4,
		  y: 2,
	      };
	      this.size = 30;
	  }

	  draw(ctx) {
	      ctx.drawImage(this.image, this.position.x, this.position.y, this.size, this.size);
	  }

	  update(deltaTime) {
	      this.position.x += this.speed.x;
	      this.position.y += this.speed.y;
	      // wall on left or right
	      if (this.position.x > this.gameWidth - this.size || this.position.x < 0) {
		  this.speed.x = -this.speed.x;
	      }
	      // wall on top or bottom
	      if (this.position.y > this.gameHeight - this.size || this.position.y < 0) {
		  this.speed.y = -this.speed.y;
	      }
	      // check collision with paddle
	      let bottomOfBall = this.position.y + this.size;
	      let topOfPaddle = this.game.paddle.position.y;
	      let leftSideOfPaddle = this.game.paddle.position.x;
	      let rightSideOfPaddle = this.game.paddle.position.x + this.game.paddle.width;
	      if (bottomOfBall >= topOfPaddle
		  && this.position.x >= leftSideOfPaddle
		  && this.position.x + this.size <= rightSideOfPaddle) {
		  this.speed.y = -this.speed.y;
		  this.position.y = this.game.paddle.position.y - this.size;
	      }
	  }
	  
      }
      
      class Brick {
	  constructor(game, position) {
	      this.image = document.querySelector("#img-brick");

	      this.game = game;
	      this.position = position;
	      this.width = 30;
	      this.height = 30;
	      
	  }

	  update() {
	      
	  }

	  draw(ctx) {
	      ctx.drawImage(this.image, this.position.x, this.position.y, this.width, this.height);
	  }

      }


      class Game {
	  constructor(gameWidth, gameHeight) {
	      this.gameWidth = gameWidth;
	      this.gameHeight = gameHeight;
	      
	  }
	  
	  start() {
	      this.paddle = new Paddle(this);
	      this.ball = new Ball(this);
	      new InputHandler(this.paddle);

	      let bricks = [];
	      for (let i = 0; i < 19; i++) {
		  bricks.push(new Brick(this, {x: i * 40, y: 20}));
	      }

	      this.gameObjects = [
		  this.ball,
		  this.paddle,
		  ...bricks,
	      ];

	  }

	  update(deltaTime) {
	      this.gameObjects.forEach(object => object.update(deltaTime));
	  }

	  draw(ctx) {
	      this.gameObjects.forEach(object => object.draw(ctx));

	  }
      }


      
      
      let game = new Game(gameWidth, gameHeight);
      game.start();

      let lastTime = 0;

      function gameLoop(timestamp) {
	  let deltaTime = timestamp - lastTime;
	  lastTime = timestamp;
	  ctx.clearRect(0, 0, gameWidth, gameHeight);
	  game.update(deltaTime);
	  game.draw(ctx);

	  
	  requestAnimationFrame(gameLoop);
      }

      requestAnimationFrame(gameLoop);



    </script>

  </body>
</html>
